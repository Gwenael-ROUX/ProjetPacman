package gameplay;import gameplay.EntityCharacter;import moteurs.Position;import moteurs.physics.BoxCollider;import moteurs.physics.Displacement;import java.util.TimerTask;public class PacmanGame extends TimerTask {    private EntityCharacter[] behaviours;    private Position initMapLimit;    private Position mapLimit;    public PacmanGame(Position mapLimit, EntityCharacter[] behaviours){        this.behaviours = behaviours;        initMapLimit = new Position(0, 0);        this.mapLimit = mapLimit;    }    @Override    public void run() {        Position[] prevDisp = new Position[behaviours.length];        // Deplacements        for(int i = 0; i < behaviours.length; i++){            EntityCharacter entityCharacter = behaviours[i];            Displacement displacement = entityCharacter.getController().move();            double xDisp = 0, yDisp = 0;            prevDisp[i] = new Position(entityCharacter.getPosition().getX(), entityCharacter.getPosition().getY());            switch (displacement){                case UP:                    yDisp -= entityCharacter.getPhysics().getSpeed();                    break;                case DOWN:                    yDisp += entityCharacter.getPhysics().getSpeed();                    break;                case LEFT:                    xDisp -= entityCharacter.getPhysics().getSpeed();                    break;                case RIGHT:                    xDisp += entityCharacter.getPhysics().getSpeed();                    break;                default:                    break;            }            entityCharacter.update(new Position(prevDisp[i].getX()+xDisp, prevDisp[i].getY()+yDisp));        }        // Gestion des collisions        // TODO : Change collision management (bug : Pacman can move on a Ghost)        // TODO : Add collision management between Ghost and Pacman (with and without bonus)        for(int i = 0; i < behaviours.length-1; i++){            for(int j = i+1; j < behaviours.length; j++){                // TODO : Suppress cast in the future                if(behaviours[i].getCollider().hit((BoxCollider) behaviours[j].getCollider())){                    behaviours[i].update(new Position(prevDisp[i].getX(), prevDisp[i].getY()));                    behaviours[j].update(new Position(prevDisp[j].getX(), prevDisp[j].getY()));                }            }        }        // Gestion des sorties de terrains        for(int i = 0; i < behaviours.length; i++){            if(behaviours[i].getCollider().exit(initMapLimit, mapLimit)){                behaviours[i].update(new Position(prevDisp[i].getX(), prevDisp[i].getY()));            }        }    }}